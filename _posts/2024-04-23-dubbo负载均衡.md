---
layout: post
category: rpc
---
# Dubbo负载均衡策略

## 随机权重

随机，按权重设置随机概率。

在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重（监控界面可以倍权、半权）。

1、获取每个Invoker的权重（权重预热），及总权重

2、如果每个权重相等，随机选择Invoker

3、根据总权重，生成一个随机int值，看看落在哪个权重区间。

举例

假定有3台dubbo provider:
- 10.0.0.1:20884, weight=2
- 10.0.0.1:20886, weight=3
- 10.0.0.1:20888, weight=4

随机算法的实现：
totalWeight=9;

假设offset=1（即random.nextInt(9)=1）

1-2=-1<0？是，所以选中 10.0.0.1:20884, weight=2

假设offset=4（即random.nextInt(9)=4）

4-2=2<0？否，这时候offset=2， 2-3<0？是，所以选中 10.0.0.1:20886, weight=3

假设offset=7（即random.nextInt(9)=7）

7-2=5<0？否，这时候offset=5， 5-3=2<0？否，这时候offset=2， 2-4<0？是，所以选中 10.0.0.1:20888, weight=4

## 轮询权重
轮循，按公约后的权重设置轮循比率。

存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

当这个机器的权重很低，其实也不会很多请求到此机器。

 

1、每个service+method，作为key，保存请求的序号。

2、如果权重（预热权重）相等，每个invoker依次处理请求。

3、不等的话，按权重承担请求份额。

## 最小活跃度
最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。

使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

相比来说，LeastActiveLoadBalance 是 RandomLoadBalance 的加强版，基于最少活跃调用数。

每次真正调用前，活跃度+1，调用完成，活跃度-1。所以，活跃度越小，说明处理越快，可以承担更多的请求量。

1、遍历 invokers 列表，寻找活跃数最小的 Invoker

2、如果有多个 Invoker 具有相同的最小活跃数，此时记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等 

3、如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可

4、如果有多个 Invoker 具有最小活跃数，且它们的权重（预热权重）不相等，此时处理方式和 RandomLoadBalance 一致

5、如果有多个 Invoker 具有最小活跃数，但它们的权重相等，此时随机返回一个即可

所以我觉得最小活跃数负载均衡的全称应该叫做：有最小活跃数用最小活跃数，没有最小活跃数根据权重选择，权重一样则随机返回的负载均衡算法

## 一致性hash
一致性 Hash，相同参数的请求总是发到同一提供者。

当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点（默认160个），平摊到其它提供者，不会引起剧烈变动。