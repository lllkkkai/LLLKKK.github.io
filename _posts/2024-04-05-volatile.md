---
layout: post
category: Java
---

在了解volatile关键字之前，你需要提前了解：
1. CPU是如何与内存交互的
2. 一点点并发与多线程

## 内存模型
![alt text](../assets/img/CPU与内存.png)
CPU是计算机的核心部件，负责执行程序中的指令。然而，CPU的执行速度远快于内存的访问速度，这就导致了CPU与内存之间的速度不匹配问题。为了解决这个问题，计算机在CPU和内存之间引入了高速缓存（Cache）。

高速缓存位于CPU内部或附近，其访问速度远快于主内存。当CPU需要读取或写入数据时，它首先会查看高速缓存中是否已经有这些数据。如果数据已经在缓存中（缓存命中），那么CPU就可以直接从缓存中读取或写入数据，而无需访问主内存，从而大大提高了访问速度。如果数据不在缓存中（缓存未命中），那么CPU就会从主内存中读取或写入数据，并将相关数据块存入缓存中，以便将来能够快速访问。

内存（RAM）是计算机中的主要存储设备，用于存储程序和数据。当CPU需要执行程序时，它会将程序的一部分加载到高速缓存中，并从缓存中读取指令执行。当需要的数据不在缓存中时，CPU会向内存发出请求，将所需数据从内存中读取到缓存中。

总的来说，CPU、高速缓存和内存之间的交互是通过缓存命中、缓存未命中和数据读写操作来实现的。这种交互方式大大减少了CPU等待内存访问的时间，提高了计算机的整体性能。

## 内存屏障（Memory Barrier）
是计算机系统中用于控制指令顺序执行和内存可见性的一种机制。它是一种特殊的指令，用于强制处理器或编译器在执行指令序列时遵守特定的内存访问顺序。

内存屏障的存在确保了多线程程序在访问共享内存时的一致性和可见性，避免了由于编译器优化或硬件乱序执行而引起的数据不一致问题。

## 并发与多线程
- 原子性（Atomicity）：指一个操作是不可分割的，要么全部执行成功，要么全部失败，不存在中间状态。在多线程环境下，原子操作是指不会被其他线程中断或同时执行的操作。例如，对于一个整型变量的赋值操作，在原子操作中要么完全成功完成赋值，要么完全不改变变量的值，不会出现部分赋值的情况。
- 可见性（Visibility）：指一个线程对共享变量的修改对其他线程是可见的。在多线程环境下，如果一个线程修改了共享变量的值，其他线程应该能够立即看到这个变化。否则，就可能出现由于缓存或优化等原因导致的数据不一致性问题。
- 有序性（Ordering）：指程序执行的顺序和代码编写的顺序一致。在多线程环境下，有序性要求程序按照代码的书写顺序执行，不会因为编译器或处理器的优化而改变代码的执行顺序。这样可以确保程序的逻辑正确性。

## volatile
### 作用
修饰变量，确保多线程环境下对该变量的读取和修改都是可见和有序的。可以用它来实现轻量级的同步机制。

### 可见性
在没有同步机制的情况下，线程之间的共享变量可能会出现不一致的情况，这就是经典的线程安全问题之一。volatile关键字就是为了解决这个问题而设计的。

Java内存模型（JMM）通过“主内存”和“工作内存”的概念来抽象地描述多线程环境下的内存可见性问题。每个线程都有自己的工作内存，用于存储该线程对共享变量的副本。当线程需要读取或写入共享变量时，它首先会在自己的工作内存中操作这个变量的副本，然后再将结果同步回主内存或从主内存中更新副本。

对于volatile变量，JMM规定了特殊的访问规则：

写操作：当一个线程修改一个volatile变量的值时，JMM会立即将这个修改同步回主内存。
读操作：当一个线程读取一个volatile变量的值时，JMM会确保该线程的工作内存中不存在这个变量的副本，或者这个副本的值已经是最新的（即与主内存中的值一致）。因此，线程会直接从主内存中读取这个变量的值。

### 有序性
- 写操作：

当我们写入一个volatile变量时，JVM会在这个写操作前插入一个写屏障（Store Barrier），确保在这个写操作之前的所有普通写操作都已经刷新到主存中。同时，它还会在这个写操作后插入一个读屏障（Load Barrier），防止后续的读操作被重排序到这个写操作之前。

- 读操作：
  
当我们读取一个volatile变量时，JVM会在这个读操作前插入一个读屏障，确保在这个读操作之前的所有普通读操作都已经完成。这确保了线程能够读取到最新的、从主存中同步过来的值。

```
public class VolatileExample {  
    private volatile boolean flag = false;  
  
    public void writer() {  
        flag = true; // volatile写，隐式插入写屏障  
        // 后续代码不会被重排序到flag赋值之前  
        // ...  
    }  
  
    public void reader() {  
        if (flag) { // volatile读，隐式插入读屏障  
            // 由于flag是volatile变量，这里能够确保看到flag的最新值  
            // ...  
        }  
    }  
}
```
在这个例子中，flag是一个volatile变量。当writer方法被调用时，它会将flag设置为true。由于flag是volatile的，JVM会在这一写操作前后隐式地插入内存屏障，确保写操作的原子性和可见性。

同样地，当reader方法被调用时，它会读取flag的值。由于flag是volatile的，JVM会在这一读操作前隐式地插入内存屏障，确保读取到的是最新的值。

在底层实现上，JVM会根据具体的硬件和操作系统来插入适当的内存屏障指令，以确保Java内存模型的一致性。这些内存屏障指令是平台相关的，不同的处理器架构可能会有不同的实现方式。但无论如何，Java开发者不需要直接操作内存屏障，只需正确使用volatile、synchronized等关键字或并发工具类即可。

### 不能保证原子性
对于count++这样的操作，它实际上包含了读取、修改和写入三个步骤，而volatile只能确保这三个步骤的可见性，但不能确保它们作为一个整体是原子的。因此，在需要原子性保证的场景下，应该使用synchronized关键字或其他并发控制工具。

此外，volatile也不能解决线程间的顺序问题，即不能保证线程的执行顺序与代码顺序一致。如果需要确保顺序性，还需要结合其他同步措施。