---
layout: post
category: Java
---

## Java文件是如何被运行的
1. 编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载
2. JVM 找到 App 的主程序入口，执行main方法
3. 这个main中的第一条语句为 Student student = new Student("tellUrDream") ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中

    1. 在方法区存储基本的类信息以及数据结构，类的对象实例是创建在堆，在那里分配内存
4. 加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 **指向方法区中的 Student 类的类型信息** 的引用
5. 执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。
6. 执行sayName()
## JVM的内存分配
自动内存管理的根本目标：

> **自动给对象分配内存，自动回收分配给对象的内存**

### 程序计数器 Program Counter Register

是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存

### 虚拟机栈 VM Stack

JVM Stack（Stack 或虚拟机栈、线程栈、栈）中存放的就是 Stack Frame（Frame 或栈帧、方法栈）

一个线程对应一个 JVM Stack。JVM Stack 中包含一组 Stack Frame。线程每调用一个方法就对应着 JVM Stack 中 Stack Frame 的入栈，方法执行完毕或者异常终止对应着出栈（销毁）。

当 JVM 调用一个 Java 方法时，它从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小，并据此分配栈帧内存，然后压入 JVM 栈中。

在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。

### 本地方法栈 Native Method Stack

虚拟机栈是为Java方法服务，本地方法栈是为Native方法服务

### 方法区 Method Area

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。

**运行时常量池**（Runtime Constant Pool）是方法区的一部分。

### 堆 Heap

所有线程共享的内存区域，虚拟机启动时创建。存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。

堆也是垃圾收集器管理的内存区域，某些资料称它为GC堆，

根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的 内存空间。 Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java虚拟机将会抛出OutOfMemoryError异常。

### 直接内存（Direct Memory）

并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所 以我们放到这里一起讲解。 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。 显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常

## 哪些区域可能会发生 OOM

### 1. 堆内存
**原因**：Java 堆是用于存储对象实例的区域。如果不断创建新的对象，并且这些对象无法被垃圾回收器及时回收，堆内存就会不断被占用，直到达到堆的最大限制，从而引发 OOM。这通常是由于内存泄漏（对象不再使用但仍然被引用）或者对象创建过多导致的。

**示例场景**：
- **内存泄漏**：在一个 Web 应用中，如果在每次处理请求时都创建新的对象，并且这些对象的引用被错误地保留在某个静态集合中，随着请求的不断增加，堆内存会逐渐被耗尽。
- **对象创建过多**：例如在一个数据处理程序中，一次性加载大量的数据到内存中，创建大量的对象，而堆内存不足以容纳这些对象，就会导致 OOM。

**异常信息**：`java.lang.OutOfMemoryError: Java heap space`

### 2. Java 虚拟机栈和本地方法栈
**原因**：虚拟机栈和本地方法栈是线程私有的，每个线程在执行方法时会创建栈帧，栈帧中存储着局部变量表、操作数栈等信息。如果线程请求的栈深度超过了虚拟机所允许的最大深度，就会抛出 `StackOverflowError`；如果虚拟机栈可以动态扩展，并且在扩展时无法申请到足够的内存，就会抛出 OOM。

**示例场景**：
- **栈深度过大**：在递归调用方法时，如果没有正确的终止条件，会导致方法不断递归调用，栈帧不断入栈，最终栈深度超过限制，抛出 `StackOverflowError`。
- **线程创建过多**：每个线程都需要占用一定的栈空间，如果创建了大量的线程，会导致栈空间耗尽，从而引发 OOM。

**异常信息**：
- **栈深度过大**：`java.lang.StackOverflowError`
- **栈扩展失败**：`java.lang.OutOfMemoryError: unable to create new native thread`

### 3. 直接内存
**原因**：直接内存并不是 JVM 运行时数据区的一部分，但在 NIO（New Input/Output）中，会使用 `DirectByteBuffer` 类直接分配堆外内存。如果直接内存的分配量超过了系统的可用内存，就会导致 OOM。

**示例场景**：在使用 NIO 进行文件读写或者网络通信时，如果频繁创建 `DirectByteBuffer` 对象，并且没有及时释放这些对象所占用的内存，会导致直接内存不断增长，最终引发 OOM。

**异常信息**：`java.lang.OutOfMemoryError: Direct buffer memory`

### 4. 方法区
**永久代（JDK 1.8 之前）**：永久代用于存储类的元数据、常量池、静态变量等信息。如果加载的类过多，或者常量池中的常量过多，会导致永久代空间不足，从而引发 OOM。

**元空间（JDK 1.8 及以后）**：元空间使用本地内存来存储类的元数据，默认情况下只受限于系统的可用内存。但如果加载了大量的类，或者元空间的大小设置不合理，也可能会导致元空间内存不足，抛出 OOM。

**示例场景**：
- **动态类加载**：在一些框架（如 Spring、Hibernate 等）中，会动态加载大量的类。如果这些类没有被正确卸载，会导致元空间不断增长，最终引发 OOM。
- **常量池过大**：在代码中使用了大量的字符串常量，或者通过反射创建了大量的常量对象，会导致常量池占用过多的空间，从而引发 OOM。

**异常信息**：
- **永久代**：`java.lang.OutOfMemoryError: PermGen space`
- **元空间**：`java.lang.OutOfMemoryError: Metaspace`

## JVM占用内存为何会超过Xmx

Xmx只控制java heap，还有堆外、线程等占用的空间。

Java8给HotSpot VM引入了Native Memory Tracking (NMT)特性，可以用于追踪JVM的内部内存使用，一般在压测调参的时候使用，生产环境不要引入，根据Java官方文档，开启NMT会有5%－10%的性能损耗。
设置启动参数，
-XX:NativeMemoryTracking=detail
开启NMT。使用NMT查询jvm内存使用情况，执行命令
jcmd 573 VM.native_memory summary scale=MB

从NMT的结果，可以看到整个memory主要包含了Java Heap、Class、Thread、Code、GC、Internal、Symbol、Native Memory Tracking这几部分。（reserved表示应用可用的内存大小，committed表示应用正在使用的内存大小）。

- Java Heap: 堆内存，即 -Xmx 限制的最大堆大小的内存。
- Class：加载的类与方法信息，即metaspace，包含两部分：一是 metadata，被 -XX:MaxMetaspaceSize 限制最大大小，另外是 class space，被 -XX:CompressedClassSpaceSize 限制最大大小
- Thread：线程与线程栈占用内存，每个线程栈占用大小受 -Xss 限制，但是总大小没有限制。
- Code：JIT 即时编译后（C1 C2 编译器优化）的代码占用内存，受 -XX:ReservedCodeCacheSize 限制
- GC：垃圾回收占用内存，例如垃圾回收需要的 CardTable，标记数，区域划分记录，还有标记 GC Root 等等，都需要内存。
- Internal：命令行解析，JVMTI 使用的内存，这个不受限制，一般不会很大的
- Symbol: 常量池占用的大小，字符串常量池受 -XX:StringTableSize 个数限制，总内存大小不受限制
- Native Memory Tracking：内存采集本身占用的内存大小

这里也就解释了为何Jvm占用内存会超过 Xmx，Xmx只控制java heap，还有堆外、线程等占用的空间。