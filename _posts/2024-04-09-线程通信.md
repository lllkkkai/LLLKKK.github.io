---
layout: post
category: Java
---

线程间通信模型：共享内存和消息传递，以下方式都是基于这两种模型实现的
# 1.synchronized和wait/notify机制
一个线程调用 Object 的 wait() 方法，使其线程被阻塞；另一线程调用 Object 的 notify()/notifyAll() 方法，wait() 阻塞的线程继续执行。

在执行 wait() 方法前，当前线程必须已获得对象锁。调用它时会阻塞当前线程，进入等待状态，在当前 wait() 处暂停线程。同时，wait() 方法执行后，会立即释放获得的对象锁。

同样，在执行 notify() 方法前，当前线程也必须已获得线程锁。调用 notify() 方法后，会通知一个执行了 wait() 方法的阻塞等待线程，使该等待线程重新获取到对象锁，然后继续执行 wait() 后面的代码。但是，与 wait() 方法不同，执行 notify() 后，不会立即释放对象锁，而需要执行完 synchronized 的代码块或方法才会释放锁，所以接收通知的线程也不会立即获得锁，也需要等待执行 notify() 方法的线程释放锁后再获取锁。
> 1. A线程获取锁，调用wait方法，释放锁
> 2. B线程获取锁，调用notify方法，继续执行完sychronized代码块，释放锁
> 3. A线程获取锁，继续wait方法后的代码执行
```Java
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5};

        Thread t1 = new Thread() {
            @Override
            public void run() {
                    synchronized (lock) {
                        try{
                            lock.wait();
                        } catch (Exception e){
                            e.printStackTrace();
                        }
                        System.out.println("t1 output:" + nums[index]);
                        index++;
                    }
            }
        };
        Thread t2 = new Thread() {
            @Override
            public void run() {
                    synchronized (lock) {
                        try{
                            lock.notify();
                        } catch (Exception e){
                            e.printStackTrace();
                        }
                        System.out.println("t2 output:" + nums[index]);
                        index++;
                    }
            }
        };
        t1.start();
        t2.start();
    }
```

线程状态说明：
- A线程调用wait方法，从RUNNING到WAITING
- B线程调用notify方法，如果B线程未执行完，A线程从WAITING到BLOCKED（synchronized的锁）
- B线程执行完，A线程从BLOCKED到RUNNING

# 2.volatile加while轮询
A线程操作临界资源的同时，B线程在while循环内不断判断volatile声明的临界资源是否满足操作条件

# 3.ReentrantLock和Condition
ReentrantLock使用Condition阻塞队列的await() signal() signal() 三个方法来实现线程阻塞和运行两个状态的切换

# 4.LockSupport实现线程间通信和阻塞
使用需要知道线程的名字

# 5.通过Socket网络通信

# 6.信号量机制

# 7.管道通信