---
layout: post
category: linux
---

# 死锁

## 定义



## 四个必要条件

1. 互斥
2. 请求和保持
3. 不可剥夺
4. 环路等待

## 如何解决

### 1.预防死锁 
1. 资源一次性分配
2. 只要有一个资源得不到分配，也不分配其他资源
3. 可剥夺资源
4. 资源有序分配法

### 2.避免死锁

### 3.检测死锁

### 4.解除死锁



```java
public class CloneDemo {
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.setName("张三");
        p1.setAge(18);
        Address address = new Address();
        address.setCity("北京");
        p1.setAddress(address);
        // 拷贝 p1 对象
        Person p2 = p1.clone();
        System.out.println(p1 == p2); // false
        System.out.println(p1.getAddress() == p2.getAddress()); // true
    }
}
class Person implements Cloneable {
    private String name;
    private int age;
    private Address address; // 引用类型
    @Override
    public Person clone() {
        Person person = null;
        try {
            person = (Person) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return person;
    }
    // 忽略 getter 和 setter 方法
}

class Address {
    private String city;

    // 忽略 getter 和 setter 方法
}

```

## 深拷贝实现

深拷贝的实现方法有很多，比如以下几个：

1. 所有引用属性都实现拷贝，整个对象就变成了深拷贝。
2. 使用 JDK 自带的字节流序列化和反序列化对象实现深拷贝。
3. 使用第三方工具实现深拷贝，比如 Apache Commons Lang。
4. 使用 JSON 工具，如 GSON、FastJSON、Jackson 序列化和反序列化对象实现深拷贝。

比较常用的深拷贝实现是，第一种让所有引用类型的属性实现拷贝，和第四种使用 JSON 工具实现深拷贝。

> 在 Java 中，序列化是指将对象转换为字节流的过程，以便可以将其存储在文件中、通过网络发送或在进程之间传递。反序列化是指将字节流转换回对象的过程。

### 深拷贝实现一：重载clone方法去复制引用类型

```java
import lombok.Getter;
import lombok.Setter;

public class CloneDemo {
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.setName("张三");
        p1.setAge(18);
        // 引用类型
        Address address = new Address();
        address.setCity("北京");
        p1.setAddress(address);
        // 拷贝 p1 对象
        Person p2 = p1.clone();
        // 对比引用类型的地址值是否相同
        System.out.println(p1.getAddress() == p2.getAddress()); // false
    }
}

@Getter
@Setter
class Person implements Cloneable {
    private String name;
    private int age;
    private Address address; // 引用类型

    @Override
    public Person clone() {
        Person person = null;
        try {
            person = (Person) super.clone();
            // address对象要调用对应的clone方法重新赋值
            person.setAddress(person.getAddress().clone());
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return person;
    }
}

@Getter
@Setter
class Address implements Cloneable {
    private String city;

    @Override
    public Address clone() {
        Address address = null;
        try {
            address = (Address) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return address;
    }
}

```

### 深拷贝实现二：使用 JSON 工具（序列化和反序列化实现）

使用 Google 的 GSON（JSON）工具类来实现：

```java
import com.google.gson.Gson;
import lombok.Getter;
import lombok.Setter;

public class CloneDemo {
    public static void main(String[] args) {
        Person p1 = new Person();
        p1.setName("张三");
        p1.setAge(18);
        // 引用类型
        Address address = new Address();
        address.setCity("北京");
        p1.setAddress(address);
        // JSON 工具类
        Gson gson = new Gson();
        // 序列化
        String json = gson.toJson(p1);
        // 拷贝 p1 对象 | 反序列化
        Person p2 = gson.fromJson(json, Person.class);
        // 对比引用类型的地址值是否相同
        System.out.println(p1.getAddress() == p2.getAddress()); //false
    }
}

@Getter
@Setter
class Person implements Cloneable {
    private String name;
    private int age;
    private Address address; // 引用类型

    @Override
    public Person clone() {
        Person person = null;
        try {
            person = (Person) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return person;
    }
}

@Getter
@Setter
class Address {
    private String city;
}

```